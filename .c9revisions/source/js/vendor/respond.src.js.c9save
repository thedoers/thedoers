{"ts":1373376475937,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas. Dual MIT/BSD license */\n/*! NOTE: If you're already including a window.matchMedia polyfill via Modernizr or otherwise, you don't need this part */\n\nwindow.matchMedia = window.matchMedia || (function( doc, undefined ) {\n\n  \"use strict\";\n\n  var bool,\n      docElem = doc.documentElement,\n      refNode = docElem.firstElementChild || docElem.firstChild,\n      // fakeBody required for <FF4 when executed in <head>\n      fakeBody = doc.createElement( \"body\" ),\n      div = doc.createElement( \"div\" );\n\n  div.id = \"mq-test-1\";\n  div.style.cssText = \"position:absolute;top:-100em\";\n  fakeBody.style.background = \"none\";\n  fakeBody.appendChild(div);\n\n  return function(q){\n\n    div.innerHTML = \"&shy;<style media=\\\"\" + q + \"\\\"> #mq-test-1 { width: 42px; }</style>\";\n\n    docElem.insertBefore( fakeBody, refNode );\n    bool = div.offsetWidth === 42;\n    docElem.removeChild( fakeBody );\n\n    return {\n      matches: bool,\n      media: q\n    };\n\n  };\n\n}( document ));\n\n\n\n\n\n/*! Respond.js v1.1.0: min/max-width media query polyfill. (c) Scott Jehl. MIT/GPLv2 Lic. j.mp/respondjs  */\n(function( win ){\n\n\t\"use strict\";\n\n\t//exposed namespace\n\tvar respond = {};\n\twin.respond = respond;\n\t\n\t//define update even in native-mq-supporting browsers, to avoid errors\n\trespond.update = function(){};\n\t\n\t//expose media query support flag for external use\n\trespond.mediaQueriesSupported\t= win.matchMedia && win.matchMedia( \"only all\" ).matches;\n\t\n\t//if media queries are supported, exit here\n\tif( respond.mediaQueriesSupported ){\n\t\treturn;\n\t}\n\t\n\t//define vars\n\tvar doc = win.document,\n\t\tdocElem = doc.documentElement,\n\t\tmediastyles = [],\n\t\trules = [],\n\t\tappendedEls = [],\n\t\tparsedSheets = {},\n\t\tresizeThrottle = 30,\n\t\thead = doc.getElementsByTagName( \"head\" )[0] || docElem,\n\t\tbase = doc.getElementsByTagName( \"base\" )[0],\n\t\tlinks = head.getElementsByTagName( \"link\" ),\n\t\trequestQueue = [],\n\t\t\n\t\t//loop stylesheets, send text content to translate\n\t\tripCSS = function(){\n\n\t\t\tfor( var i = 0; i < links.length; i++ ){\n\t\t\t\tvar sheet = links[ i ],\n\t\t\t\thref = sheet.href,\n\t\t\t\tmedia = sheet.media,\n\t\t\t\tisCSS = sheet.rel && sheet.rel.toLowerCase() === \"stylesheet\";\n\n\t\t\t\t//only links plz and prevent re-parsing\n\t\t\t\tif( !!href && isCSS && !parsedSheets[ href ] ){\n\t\t\t\t\t// selectivizr exposes css through the rawCssText expando\n\t\t\t\t\tif (sheet.styleSheet && sheet.styleSheet.rawCssText) {\n\t\t\t\t\t\ttranslate( sheet.styleSheet.rawCssText, href, media );\n\t\t\t\t\t\tparsedSheets[ href ] = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif( (!/^([a-zA-Z:]*\\/\\/)/.test( href ) && !base) ||\n\t\t\t\t\t\t\thref.replace( RegExp.$1, \"\" ).split( \"/\" )[0] === win.location.host ){\n\t\t\t\t\t\t\trequestQueue.push( {\n\t\t\t\t\t\t\t\thref: href,\n\t\t\t\t\t\t\t\tmedia: media\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmakeRequests();\n\t\t},\n\t\t\n\t\t//recurse through request queue, get css text\n\t\tmakeRequests\t= function(){\n\t\t\tif( requestQueue.length ){\n\t\t\t\tvar thisRequest = requestQueue.shift();\n\t\t\t\t\n\t\t\t\tajax( thisRequest.href, function( styles ){\n\t\t\t\t\ttranslate( styles, thisRequest.href, thisRequest.media );\n\t\t\t\t\tparsedSheets[ thisRequest.href ] = true;\n\n\t\t\t\t\t// by wrapping recursive function call in setTimeout \n\t\t\t\t\t// we prevent \"Stack overflow\" error in IE7\n\t\t\t\t\twin.setTimeout(function(){ makeRequests(); },0);\n\t\t\t\t} );\n\t\t\t}\n\t\t},\n\t\t\n\t\t//find media blocks in css text, convert to style blocks\n\t\ttranslate = function( styles, href, media ){\n\t\t\tvar qs = styles.match(  /@media[^\\{]+\\{([^\\{\\}]*\\{[^\\}\\{]*\\})+/gi ),\n\t\t\t\tql = qs && qs.length || 0;\n\n\t\t\t//try to get CSS path\n\t\t\thref = href.substring( 0, href.lastIndexOf( \"/\" ) );\n\n\t\t\tvar repUrls\t= function( css ){\n\t\t\t\t\treturn css.replace( /(url\\()['\"]?([^\\/\\)'\"][^:\\)'\"]+)['\"]?(\\))/g, \"$1\" + href + \"$2$3\" );\n\t\t\t\t},\n\t\t\t\tuseMedia = !ql && media;\n\n\t\t\t//if path exists, tack on trailing slash\n\t\t\tif( href.length ){ href += \"/\"; }\t\n\t\t\t\t\n\t\t\t//if no internal queries exist, but media attr does, use that\t\n\t\t\t//note: this currently lacks support for situations where a media attr is specified on a link AND\n\t\t\t\t//its associated stylesheet has internal CSS media queries.\n\t\t\t\t//In those cases, the media attribute will currently be ignored.\n\t\t\tif( useMedia ){\n\t\t\t\tql = 1;\n\t\t\t}\n\n\t\t\tfor( var i = 0; i < ql; i++ ){\n\t\t\t\tvar fullq, thisq, eachq, eql;\n\n\t\t\t\t//media attr\n\t\t\t\tif( useMedia ){\n\t\t\t\t\tfullq = media;\n\t\t\t\t\trules.push( repUrls( styles ) );\n\t\t\t\t}\n\t\t\t\t//parse for styles\n\t\t\t\telse{\n\t\t\t\t\tfullq = qs[ i ].match( /@media *([^\\{]+)\\{([\\S\\s]+?)$/ ) && RegExp.$1;\n\t\t\t\t\trules.push( RegExp.$2 && repUrls( RegExp.$2 ) );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\teachq = fullq.split( \",\" );\n\t\t\t\teql\t= eachq.length;\n\t\t\t\t\t\n\t\t\t\tfor( var j = 0; j < eql; j++ ){\n\t\t\t\t\tthisq = eachq[ j ];\n\t\t\t\t\tmediastyles.push( { \n\t\t\t\t\t\tmedia : thisq.split( \"(\" )[ 0 ].match( /(only\\s+)?([a-zA-Z]+)\\s?/ ) && RegExp.$2 || \"all\",\n\t\t\t\t\t\trules : rules.length - 1,\n\t\t\t\t\t\thasquery : thisq.indexOf(\"(\") > -1,\n\t\t\t\t\t\tminw : thisq.match( /\\(\\s*min\\-width\\s*:\\s*(\\s*[0-9\\.]+)(px|em)\\s*\\)/ ) && parseFloat( RegExp.$1 ) + ( RegExp.$2 || \"\" ), \n\t\t\t\t\t\tmaxw : thisq.match( /\\(\\s*max\\-width\\s*:\\s*(\\s*[0-9\\.]+)(px|em)\\s*\\)/ ) && parseFloat( RegExp.$1 ) + ( RegExp.$2 || \"\" )\n\t\t\t\t\t} );\n\t\t\t\t}\t\n\t\t\t}\n\n\t\t\tapplyMedia();\n\t\t},\n        \n\t\tlastCall,\n\t\t\n\t\tresizeDefer,\n\t\t\n\t\t// returns the value of 1em in pixels\n\t\tgetEmValue = function() {\n\t\t\tvar ret,\n\t\t\t\tdiv = doc.createElement('div'),\n\t\t\t\tbody = doc.body,\n\t\t\t\tfakeUsed = false;\n\t\t\t\t\t\t\t\t\t\n\t\t\tdiv.style.cssText = \"position:absolute;font-size:1em;width:1em\";\n\t\t\t\t\t\n\t\t\tif( !body ){\n\t\t\t\tbody = fakeUsed = doc.createElement( \"body\" );\n\t\t\t\tbody.style.background = \"none\";\n\t\t\t}\n\t\t\t\t\t\n\t\t\tbody.appendChild( div );\n\t\t\t\t\t\t\t\t\n\t\t\tdocElem.insertBefore( body, docElem.firstChild );\n\t\t\t\t\t\t\t\t\n\t\t\tret = div.offsetWidth;\n\t\t\t\t\t\t\t\t\n\t\t\tif( fakeUsed ){\n\t\t\t\tdocElem.removeChild( body );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbody.removeChild( div );\n\t\t\t}\n\t\t\t\n\t\t\t//also update eminpx before returning\n\t\t\tret = eminpx = parseFloat(ret);\n\t\t\t\t\t\t\t\t\n\t\t\treturn ret;\n\t\t},\n\t\t\n\t\t//cached container for 1em value, populated the first time it's needed \n\t\teminpx,\n\t\t\n\t\t//enable/disable styles\n\t\tapplyMedia = function( fromResize ){\n\t\t\tvar name = \"clientWidth\",\n\t\t\t\tdocElemProp = docElem[ name ],\n\t\t\t\tcurrWidth = doc.compatMode === \"CSS1Compat\" && docElemProp || doc.body[ name ] || docElemProp,\n\t\t\t\tstyleBlocks\t= {},\n\t\t\t\tlastLink = links[ links.length-1 ],\n\t\t\t\tnow = (new Date()).getTime();\n\n\t\t\t//throttle resize calls\t\n\t\t\tif( fromResize && lastCall && now - lastCall < resizeThrottle ){\n\t\t\t\twin.clearTimeout( resizeDefer );\n\t\t\t\tresizeDefer = win.setTimeout( applyMedia, resizeThrottle );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlastCall = now;\n\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\tfor( var i in mediastyles ){\n\t\t\t\tif( mediastyles.hasOwnProperty( i ) ){\n\t\t\t\t\tvar thisstyle = mediastyles[ i ],\n\t\t\t\t\t\tmin = thisstyle.minw,\n\t\t\t\t\t\tmax = thisstyle.maxw,\n\t\t\t\t\t\tminnull = min === null,\n\t\t\t\t\t\tmaxnull = max === null,\n\t\t\t\t\t\tem = \"em\";\n\t\t\t\t\t\n\t\t\t\t\tif( !!min ){\n\t\t\t\t\t\tmin = parseFloat( min ) * ( min.indexOf( em ) > -1 ? ( eminpx || getEmValue() ) : 1 );\n\t\t\t\t\t}\n\t\t\t\t\tif( !!max ){\n\t\t\t\t\t\tmax = parseFloat( max ) * ( max.indexOf( em ) > -1 ? ( eminpx || getEmValue() ) : 1 );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// if there's no media query at all (the () part), or min or max is not null, and if either is present, they're true\n\t\t\t\t\tif( !thisstyle.hasquery || ( !minnull || !maxnull ) && ( minnull || currWidth >= min ) && ( maxnull || currWidth <= max ) ){\n\t\t\t\t\t\tif( !styleBlocks[ thisstyle.media ] ){\n\t\t\t\t\t\t\tstyleBlocks[ thisstyle.media ] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstyleBlocks[ thisstyle.media ].push( rules[ thisstyle.rules ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//remove any existing respond style element(s)\n\t\t\tfor( var j in appendedEls ){\n\t\t\t\tif( appendedEls.hasOwnProperty( j ) ){\n\t\t\t\t\tif( appendedEls[ j ] && appendedEls[ j ].parentNode === head ){\n\t\t\t\t\t\thead.removeChild( appendedEls[ j ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//inject active styles, grouped by media type\n\t\t\tfor( var k in styleBlocks ){\n\t\t\t\tif( styleBlocks.hasOwnProperty( k ) ){\n\t\t\t\t\tvar ss = doc.createElement( \"style\" ),\n\t\t\t\t\t\tcss = styleBlocks[ k ].join( \"\\n\" );\n\t\t\t\t\t\n\t\t\t\t\tss.type = \"text/css\";\t\n\t\t\t\t\tss.media = k;\n\t\t\t\t\t\n\t\t\t\t\t//originally, ss was appended to a documentFragment and sheets were appended in bulk.\n\t\t\t\t\t//this caused crashes in IE in a number of circumstances, such as when the HTML element had a bg image set, so appending beforehand seems best. Thanks to @dvelyk for the initial research on this one!\n\t\t\t\t\thead.insertBefore( ss, lastLink.nextSibling );\n\t\t\t\t\t\n\t\t\t\t\tif ( ss.styleSheet ){ \n\t\t\t\t\t\tss.styleSheet.cssText = css;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tss.appendChild( doc.createTextNode( css ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t//push to appendedEls to track for later removal\n\t\t\t\t\tappendedEls.push( ss );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t//tweaked Ajax functions from Quirksmode\n\t\tajax = function( url, callback ) {\n\t\t\tvar req = xmlHttp();\n\t\t\tif (!req){\n\t\t\t\treturn;\n\t\t\t}\t\n\t\t\treq.open( \"GET\", url, true );\n\t\t\treq.onreadystatechange = function () {\n\t\t\t\tif ( req.readyState !== 4 || req.status !== 200 && req.status !== 304 ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcallback( req.responseText );\n\t\t\t};\n\t\t\tif ( req.readyState === 4 ){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treq.send( null );\n\t\t},\n\t\t//define ajax obj \n\t\txmlHttp = (function() {\n\t\t\tvar xmlhttpmethod = false;\t\n\t\t\ttry {\n\t\t\t\txmlhttpmethod = new win.XMLHttpRequest();\n\t\t\t}\n\t\t\tcatch( e ){\n\t\t\t\txmlhttpmethod = new win.ActiveXObject( \"Microsoft.XMLHTTP\" );\n\t\t\t}\n\t\t\treturn function(){\n\t\t\t\treturn xmlhttpmethod;\n\t\t\t};\n\t\t})();\n\t\n\t//translate CSS\n\tripCSS();\n\t\n\t//expose update for re-running respond later on\n\trespond.update = ripCSS;\n\t\n\t//adjust on resize\n\tfunction callMedia(){\n\t\tapplyMedia( true );\n\t}\n\tif( win.addEventListener ){\n\t\twin.addEventListener( \"resize\", callMedia, false );\n\t}\n\telse if( win.attachEvent ){\n\t\twin.attachEvent( \"onresize\", callMedia );\n\t}\n})(this);\n"]],"start1":0,"start2":0,"length1":0,"length2":9748}]],"length":9748}
